import { Libraries } from '@/components/Libraries'
import { Lib } from '@/components/Lib'
import { HeroPattern } from '@/components/HeroPattern'

<HeroPattern />
export const metadata = {
  title: '일반 플러그인 생성',
  description:
    '이 가이드는 Protocol API를 사용하여 API 클라이언트를 시작하고 첫 번째 API 요청을 만드는 방법을 다룹니다.',
}

# 일반 플러그인 생성

erxes를 사용하면 자체 플러그인을 생성하거나 기존 플러그인을 확장할 수 있으며, 이를 통해 제품/서비스의 가치를 추가하여 경험을 향상시키고 수익을 증가시킬 수 있습니다. 또한 [우리의 마켓플레이스](https://erxes.io/marketplace)<script src='https://cdn.jsdelivr.net/gh/eddymens/markdown-external-link-script@v2.0.0/main.min.js'></script>에서 판매할 수도 있습니다. 이 가이드는 자체 플러그인을 개발하는 데 도움을 줍니다.

<Caution>
- 자체 플러그인을 개발하기 전에 동일한 이름 또는 유사한 이름의 플러그인이 마켓플레이스에 존재하지 않는지 확인하세요. 이름은 `API`, `GraphQL`, `query`, `mutation` 등 여러 곳에서 사용되므로 혼동을 피하기 위해 중요합니다.
- 이름은 소문자만 사용하며, 기호와 공백을 포함하지 않아야 합니다.
- 모든 `GraphQL` 타입, `query`, `mutation`의 이름은 플러그인 이름으로 시작해야 합니다.
- 데이터베이스 컬렉션의 이름도 플러그인 이름으로 시작해야 합니다.
- **UIroutes** 또는 `url`의 이름도 플러그인 이름으로 시작해야 합니다.
</Caution>

# erxes 설치

---

erxes XOS를 설치하려면 [설치 가이드](/quickstart/groups)를 참조하세요. 그러나 동일한 방향으로 erxes를 실행할 필요는 없습니다.

<Danger>
erxes XOS가 이미 장치에 설치되어 있다고 가정합니다. 그렇지 않으면 아래 가이드라인이 제대로 작동하지 않을 수 있습니다. [설치 가이드](/quickstart/groups)를 사용하여 erxes XOS를 설치한 후 다시 오십시오.
</Danger>

<Libraries />

<Lib />

# 새로운 플러그인 생성

각 플러그인은 `API`와 `UI` 두 부분으로 구성됩니다.

- 다음 명령어를 사용하여 두 부분의 새 폴더를 생성하세요.

```bash {{ title: '' }}
    cd erxes
    yarn create-plugin 
```

명령어를 실행하면 CLI가 시작되며, 새 플러그인을 생성하기 위해 몇 가지 질문이 표시됩니다. 아래 예제에서는 document라는 이름의 플러그인을 생성합니다.
![](https://imagedelivery.net/5m26Aj-CutMXPPNacMs_yQ/6e30c8b7-5396-48a2-3b4a-8b2223080400/public)

아래 예제는 메인 내비게이션에 배치된 예제 템플릿에서 생성된 새 플러그인입니다.
![](https://imagedelivery.net/5m26Aj-CutMXPPNacMs_yQ/88dccd76-b921-441f-e903-7ff31b278900/public)

빈 템플릿에서 생성하면 아래와 같이 표시됩니다. 이는 erxes에서 자유롭게 플러그인을 개발할 수 있도록 공간을 제공합니다.
![](https://imagedelivery.net/5m26Aj-CutMXPPNacMs_yQ/fe16b5f8-e361-4194-87ff-772616413300/public)

# API 파일 구조

플러그인을 생성한 후에는 새 플러그인 API에 다음과 같은 파일들이 자동으로 생성됩니다.
```bash {{ title: '' }}
📦plugin-document-api
 ┣ 📂src
 ┃ ┣ 📂graphql
 ┃ ┃ ┣ 📂resolvers 
 ┃ ┃ ┃ ┣ index.ts
 ┃ ┃ ┃ ┣ mutations.ts
 ┃ ┃ ┃ ┗ queries.ts
 ┃ ┃ ┣ index.ts
 ┃ ┃ ┗ typeDefs.ts
 ┃ ┣ configs.ts
 ┃ ┣ messageBroker.ts
 ┃ ┗ models.ts
 ┣ .env.sample
 ┣ package.json
 ┗ tsconfig.json
```

### 주요 파일
plugin-[pluginName]-api/src에 다음 파일들이 자동으로 생성됩니다.

### configs.ts
이 파일은 플러그인의 주요 설정을 포함하고 있습니다.

```bash {{ title: 'configs.ts file:' }}
// path: ./packages/plugin-[pluginName]-api/src/configs.ts 
import typeDefs from './graphql/typeDefs';
import resolvers from './graphql/resolvers';
import { initBroker } from './messageBroker';
export let mainDb;
export let debug;
export let graphqlPubsub;
export let serviceDiscovery;
export default {
  name: '[pluginName]',
  graphql: async sd => {
    serviceDiscovery = sd;
    return {
      typeDefs: await typeDefs(sd),
      resolvers: await resolvers(sd)
    };
  },
  apolloServerContext: async (context) => {
    return context;
  },
  onServerInit: async options => {
    mainDb = options.db;
    initBroker(options.messageBrokerClient);
    graphqlPubsub = options.pubsubClient;
    debug = options.debug;
  }
}
```
### messageBroker.ts
이 파일은 다른 플러그인과 연결하는 데 사용됩니다. 공통 기능에서 메시지 브로커 함수를 확인할 수 있습니다.

```bash {{ title: ' messageBroker.ts file:' }}
// path: ./packages/plugin-[pluginName]-api/src/messageBroker.ts 
import { ISendMessageArgs, sendMessage } from "@erxes/api-utils/src/core";
import { serviceDiscovery } from "./configs";
import { Documents } from "./models";
let client;
export const initBroker = async cl => {
  client = cl;
  const { consumeQueue, consumeRPCQueue } = client;
  consumeQueue('document:send', async ({ data }) => {
    Documents.send(data);
    return {
      status: 'success',
    };
  });
  consumeRPCQueue('document:find', async ({ data }) => {
    return {
      status: 'success',
      data: await Documents.find({})
    };
  });
};
export const sendCommonMessage = async (
  args: ISendMessageArgs & { serviceName: string }
) => {
  return sendMessage({
    serviceDiscovery,
    client,
    ...args
  });
};
export default function() {
  return client;
}
```

## GraphQL 개발
`packages/plugin-<new_plugin>-api/src` 내부에는 `graphql` 폴더가 있습니다. 이 폴더에는 GraphQL과 관련
```tsx
 📂src
 ┣ 📂graphql
 ┃ ┣ 📂resolvers 
 ┃ ┃ ┣ index.ts
 ┃ ┃ ┣ mutations.ts
 ┃ ┃ ┗ queries.ts
 ┃ ┣ index.ts
 ┃ ┗ typeDefs.ts
 ```
### GraphQL 리졸버
`/graphql/resolvers/mutations` 내부에는 GraphQL 변이 코드가 포함되어 있습니다.

```bash {{ title: ' mutation examples:' }}
import { Documents, Types } from '../../models';
import { IContext } from "@erxes/api-utils/src/types"
const documentMutations = {
/**
 * 새로운 문서를 생성합니다
 */
async documentsAdd(_root, doc, _context: IContext) {
  return Documents.createDocument(doc);
},
/**
 * 문서를 수정합니다
 */
async documentsEdit(
  _root,
  { _id, ...doc },
  _context: IContext
) {
  return Documents.updateDocument(_id, doc);
},
/**
 * 단일 문서를 제거합니다
 */
async documentsRemove(_root, { _id }, _context: IContext) {
  return Documents.removeDocument(_id);
},
/**
 * 문서를 위한 새로운 유형을 생성합니다
 */
async documentTypesAdd(_root, doc, _context: IContext) {
  return Types.createType(doc);
},
async documentTypesRemove(_root, { _id }, _context: IContext) {
  return Types.removeType(_id);
},
async documentTypesEdit(
  _root,
  { _id, ...doc },
  _context: IContext
) {
return Types.updateType(_id, doc);
}
};
export default documentMutations;
```
### `/graphql/resolvers/queries` 폴더 내부에는 GraphQL 쿼리 코드가 포함되어 있습니다.

```bash {{ title: ' query examples:' }}
import { Documents, Types } from "../../models";
import { IContext } from "@erxes/api-utils/src/types"
const documentQueries = {
  documents(
    _root,
    {
      typeId
    },
    _context: IContext
  ) {
    const selector: any = {};
    if (typeId) {
      selector.typeId = typeId;
    }
    return Documents.find(selector).sort({ order: 1, name: 1 });
  },
  documentTypes(_root, _args, _context: IContext) {
    return Types.find({});
  },
  documentsTotalCount(_root, _args, _context: IContext) {
    return Documents.find({}).countDocuments();
  }
};
export default documentQueries;
```
### GraphQL typeDefs
`/graphql/typeDefs.ts` 파일 내부에는 GraphQL typeDefs가 포함되어 있습니다.

```bash {{ title: ' typeDefs:' }}
import { gql } from 'apollo-server-express';
const types = `
  type Document {
    _id: String!
    name: String
    createdAt:Date
    expiryDate:Date
    checked:Boolean
    typeId: String
  
    currentType: DocumentType
  }
  type DocumentType {
    _id: String!
    name: String
  }
`;
const queries = `
  documents(typeId: String): [Document]
  documentTypes: [DocumentType]
  documentsTotalCount: Int
`;
const params = `
  name: String,
  expiryDate: Date,
  checked: Boolean,
  typeId:String
`;
const mutations = `
  documentsAdd(${params}): Document
  documentsRemove(_id: String!): JSON
  documentsEdit(_id:String!, ${params}): Document
  documentTypesAdd(name:String):DocumentType
  documentTypesRemove(_id: String!):JSON
  documentTypesEdit(_id: String!, name:String): DocumentType
`;
const typeDefs = async _serviceDiscovery => {
  return gql`
    scalar JSON
    scalar Date
    ${types}
    
    extend type Query {
      ${queries}
    }
    
    extend type Mutation {
      ${mutations}
    }
  `;
};
export default typeDefs;

```

## 데이터베이스 개발
`packages/plugin-<new_plugin>-api/src` 내부에는 `models` 파일이 있습니다. 이 파일에는 MongoDB와 mongoose와 관련된 코드가 포함되어 있습니다.

```tsx
📂src
┗ models.ts
```
### Mongoose 스키마 및 모델
`src/models.ts` 파일에는 Mongoose 스키마와 모델이 포함되어 있습니다.
```bash {{ title: ' Mongoose schema and model example:' }}
import * as _ from 'underscore';
import { model } from 'mongoose';
import { Schema } from 'mongoose';
export const typeSchema = new Schema({
  name: String
});
export const documentSchema = new Schema({
  name: String,
  createdAt: Date,
  expiryDate: Date,
  checked: Boolean,
  typeId: String
});
export const loadTypeClass = () => {
  class Type {
    public static async getType(_id: string) {
      const type = await Types.findOne({ _id });
      if (!type) {
        throw new Error('Type not found');
      }
      return type;
    }
    // create type
    public static async createType(doc) {
      return Types.create({ ...doc });
    }
    // remove type
    public static async removeType(_id: string) {
      return Types.deleteOne({ _id });
    }
    public static async updateType(_id: string, doc) {
      return Types.updateOne({ _id }, { $set: { ...doc } });
    }
  }
  typeSchema.loadClass(Type);
  return typeSchema;
};
export const loadDocumentClass = () => {
  class Document {
    public static async getDocument(_id: string) {
      const document = await Documents.findOne({ _id });
      if (!document) {
        throw new Error('Document not found');
      }
      return document;
    }
    // create
    public static async createDocument(doc) {
      return Documents.create({
        ...doc,
        createdAt: new Date()
      });
    }
    // update
    public static async updateDocument (_id: string, doc) {
      await Documents.updateOne(
        { _id },
        { $set: { ...doc } }
      ).then(err => console.error(err));
    }
    // remove
    public static async removeDocument(_id: string) {
      return Documents.deleteOne({ _id });
    }
  }
documentSchema.loadClass(Document);
return documentSchema;
};
loadDocumentClass();
loadTypeClass();
// tslint:disable-next-line
export const Types = model<any, any>(
  'document_types',
  typeSchema
);
// tslint:disable-next-line
export const Documents = model<any, any>('documents', documentSchema);
```

## UI 파일 구조
`yarn-create-plugin` 명령어를 사용하여 새 플러그인을 생성한 후, 새로운 플러그인 UI에는 다음과 같은 파일이 자동으로 생성됩니다.

```tsx
📦plugin-[pluginName]-ui
 ┣ 📂src
 ┃ ┣ 📂components
 ┃ ┃ ┣ Form.tsx
 ┃ ┃ ┣ List.tsx
 ┃ ┃ ┣ Row.tsx
 ┃ ┃ ┣ SideBar.tsx
 ┃ ┃ ┗ TypeForm.tsx
 ┃ ┣ 📂containers
 ┃ ┃ ┣ List.tsx
 ┃ ┃ ┗ SideBarList.tsx
 ┃ ┣ 📂graphql
 ┃ ┃ ┣ index.ts
 ┃ ┃ ┣ mutations.ts
 ┃ ┃ ┗ queries.ts
 ┃ ┣ App.tsx
 ┃ ┣ configs.js
 ┃ ┣ generalRoutes.tsx
 ┃ ┣ index.js
 ┃ ┣ routes.tsx
 ┃ ┗ types.ts
 ```
## 주요 파일
다음 파일들은 `plugin-[pluginName]-ui/src`에 자동으로 생성됩니다.

### configs.js
이 파일에는 플러그인의 주요 설정이 포함되어 있습니다.

```bash {{ title: 'configs.js file:' }}
// path: ./packages/plugin-[pluginName]-ui/src/configs.js 
  module.exports = {
    name: '[pluginName]',
    port: 3017,
    scope: '[pluginName]',
    exposes: {
      './routes': './src/routes.tsx'
    },
    routes: {
      url: 'http://localhost:3017/remoteEntry.js',
      scope: '[pluginName]',
      module: './routes'
    },
    menus:[
        {
          "text":"[pluginName]",
          "url":"/[pluginUrl]",
          "icon":"icon-star",
          "location":"[mainNavigation or settings]"
        }
      ]
  };
  ```

### routes.tsx
이 파일에는 플러그인 UI의 라우트가 포함되어 있습니다.

```bash {{ title: 'routes.tsx file:' }}
// path: ./packages/plugin-[pluginName]-ui/src/routes.tsx 
  import asyncComponent from '@erxes/ui/src/components/AsyncComponent';
  import queryString from 'query-string';
  import React from 'react';
  import { Route } from 'react-router-dom';
  const List = asyncComponent(() =>
    import(/* webpackChunkName: "List - Documents" */ './containers/List')
  );
  const documents = ({ location, history }) => {
    const queryParams = queryString.parse(location.search);
    const { type } = queryParams;
    return <List typeId={type} history={history} />;
  };
  const routes = () => {
    return <Route path="/documents/" component={documents} />;
  };
```

### App.tsx
이 파일에는 애플리케이션의 주요 컴포넌트가 포함되어 있습니다.

```bash {{ title: 'App.tsx file:' }}
// path: ./packages/plugin-[pluginName]-ui/src/App.tsx 
  import React from 'react';
  import GeneralRoutes from './generalRoutes';
  import { PluginLayout } from '@erxes/ui/src/styles/main';
  const App = () => {
    return (
      <PluginLayout>
        <GeneralRoutes />
      </PluginLayout>
    );
  };
  export default App;
  ```

## UI 개발
### Components
`src` 폴더 내에 `components` 폴더가 있습니다. 이 폴더에는 플러그인의 주요 컴포넌트가 포함되어 있습니다.

```tsx
 📂src
 ┣ 📂components
 ┃ ┣ Form.tsx
 ┃ ┣ List.tsx
 ┃ ┣ Row.tsx
 ┃ ┣ SideBar.tsx
 ┃ ┗ TypeForm.tsx
 ```
```bash {{ title: 'components example:' }}
 // path: ./packages/plugin-[pluginName]-ui/src/components/TypeForm.tsx 
  import { __ } from '@erxes/ui/src/utils/core';
  import React from 'react';
  import { IType } from '../types';
  import { IButtonMutateProps, IFormProps } from '@erxes/ui/src/types';
  import Form from '@erxes/ui/src/components/form/Form';
  import {
    ControlLabel,
    FormControl,
    FormGroup
  } from '@erxes/ui/src/components/form';
  import Button from '@erxes/ui/src/components/Button';
  import { ModalFooter } from '@erxes/ui/src/styles/main';
  type Props = {
    renderButton: (props: IButtonMutateProps) => JSX.Element;
    closeModal?: () => void;
    afterSave?: () => void;
    remove?: (type: IType) => void;
    types?: IType[];
    type: IType;
  };
  const TypeForm = (props: Props) => {
    const { type, closeModal, renderButton, afterSave } = props;
    const generateDoc = (values: {
      _id?: string;
      name: string;
      content: string;
    }) => {
      const finalValues = values;
      const { type } = props;
      if (type) {
        finalValues._id = type._id;
      }
      return {
        ...finalValues
      };
    };
    const renderContent = (formProps: IFormProps) => {
      const { values, isSubmitted } = formProps;
      const object = type || ({} as any);
      return (
        <>
          <FormGroup>
            <ControlLabel required={true}>Todo Type</ControlLabel>
            <FormControl
              {...formProps}
              name='name'
              defaultValue={object.name}
              type='text'
              required={true}
              autoFocus={true}
            />
          </FormGroup>
          <ModalFooter id={'AddTypeButtons'}>
            <Button btnStyle='simple' onClick={closeModal} icon='times-circle'>
              Cancel
            </Button>
            {renderButton({
              passedName: 'type',
              values: generateDoc(values),
              isSubmitted,
              callback: closeModal || afterSave,
              object: type
            })}
          </ModalFooter>
        </>
      );
    };
    return <Form renderContent={renderContent} />;
  };
  export default TypeForm;
  ```

### Containers
`src` 폴더 내에 `containers` 폴더가 있습니다. 이 폴더에는 API와 관련된 코드가 포함된 컴포넌트가 포함되어 있습니다.

```tsx
 📂src
  ┣ 📂containers
  ┃ ┣ List.tsx
  ┃ ┗ SideBarList.tsx
  ```
```bash {{ title: 'containers example:' }}
  // path: ./packages/plugin-[pluginName]-ui/src/containers/SideBarList.tsx 
  import gql from 'graphql-tag';
  import * as compose from 'lodash.flowright';
  import { graphql } from 'react-apollo';
  import { Alert, confirm, withProps } from '@erxes/ui/src/utils';
  import SideBar from '../components/SideBar';
  import {
    EditTypeMutationResponse,
    RemoveTypeMutationResponse,
    TypeQueryResponse
  } from '../types';
  import { mutations, queries } from '../graphql';
  import React from 'react';
  import { IButtonMutateProps } from '@erxes/ui/src/types';
  import ButtonMutate from '@erxes/ui/src/components/ButtonMutate';
  import Spinner from '@erxes/ui/src/components/Spinner';
  type Props = {
    history: any;
    currentTypeId?: string;
  };
  type FinalProps = {
    listTemplateTypeQuery: TypeQueryResponse;
  } & Props &
    RemoveTypeMutationResponse &
    EditTypeMutationResponse;
  const TypesListContainer = (props: FinalProps) => {
    const { listTemplateTypeQuery, typesEdit, typesRemove, history } = props;
    if (listTemplateTypeQuery.loading) {
      return <Spinner />;
    }
    // calls gql mutation for edit/add type
    const renderButton = ({
      passedName,
      values,
      isSubmitted,
      callback,
      object
    }: IButtonMutateProps) => {
      return (
        <ButtonMutate
          mutation={object ? mutations.editType : mutations.addType}
          variables={values}
          callback={callback}
          isSubmitted={isSubmitted}
          type="submit"
          successMessage={`You successfully ${
            object ? 'updated' : 'added'
          } a ${passedName}`}
          refetchQueries={['listTemplateTypeQuery']}
        />
      );
    };
    const remove = type => {
      confirm('You are about to delete the item. Are you sure? ')
        .then(() => {
          typesRemove({ variables: { _id: type._id } })
            .then(() => {
              Alert.success('Successfully deleted an item');
            })
            .catch(e => Alert.error(e.message));
        })
        .catch(e => Alert.error(e.message));
    };
    const updatedProps = {
      ...props,
      types: listTemplateTypeQuery.templateTypes || [],
      loading: listTemplateTypeQuery.loading,
      remove,
      renderButton
    };
    return <SideBar {...updatedProps} />;
  };
  export default withProps<Props>(
    compose(
      graphql(gql(queries.listTemplateTypes), {
        name: 'listTemplateTypeQuery',
        options: () => ({
          fetchPolicy: 'network-only'
        })
      }),
      graphql(gql(mutations.removeType), {
        name: 'typesRemove',
        options: () => ({
          refetchQueries: ['listTemplateTypeQuery']
        })
      })
    )(TypesListContainer)
  );
  ```
### GraphQL
`src` 폴더 내에 `graphql` 폴더가 있습니다. 이 폴더에는 GraphQL과 관련된 코드가 포함되어 있습니다.
```tsx
📂src
 ┣ 📂graphql
 ┃ ┣ index.ts
 ┃ ┣ mutations.ts
 ┃ ┗ queries.ts
 ```
`/graphql/mutations.ts` 파일에는 GraphQL mutation 코드가 포함되어 있습니다.

```bash {{ title: 'GraphQL mutation examples:' }}
const add = `
  mutation documentsAdd($name: String!, $expiryDate: Date, $typeId:String) {
    documentsAdd(name:$name, expiryDate: $expiryDate, typeId:$typeId) {
      name
      _id
      expiryDate
      typeId
    }
  }
`;

const remove = `
  mutation documentsRemove($_id: String!){
    documentsRemove(_id: $_id)
  }
  `;

const edit = `
  mutation documentsEdit($_id: String!, $name:String, $expiryDate:Date, $checked:Boolean, $typeId:String){
    documentsEdit(_id: $_id, name: $name, expiryDate:$expiryDate, checked:$checked, typeId:$typeId){
      _id
    }
  }
  `;

const addType = `
  mutation typesAdd($name: String!){
    documentTypesAdd(name:$name){
      name
      _id
    }
  }
  `;

const removeType = `
  mutation typesRemove($_id:String!){
    documentTypesRemove(_id:$_id)
  }
`;

const editType = `
  mutation typesEdit($_id: String!, $name:String){
    documentTypesEdit(_id: $_id, name: $name){
      _id
    }
  }
`;

export default {
  add,
  remove,
  edit,
  addType,
  removeType,
  editType
};
```

### `/graphql/queries.ts` 파일에는 GraphQL query 코드가 포함되어 있습니다.

```bash {{ title: 'GraphQL query examples:' }}
const list = `
  query listQuery($typeId: String) {
    documents(typeId: $typeId) {
      _id
      name
      expiryDate
      createdAt
      checked
      typeId
      currentType{
        _id
        name
      }
    }
  }
`;
const listDocumentTypes = `
  query listDocumentTypeQuery{
    documentTypes{
      _id
      name
    }
  }
`;
const totalCount = `
  query documentsTotalCount{
    documentsTotalCount
  }
`;
export default {
  list,
  totalCount,
  listDocumentTypes
};
```

# UI 설정
## 플러그인 실행 포트
`packages/plugin-<new_plugin>-ui/src/configs.js` 파일 내에 플러그인 UI의 실행 포트가 설정되어 있습니다. 기본 값은 3017입니다. 각 플러그인은 고유한 포트에서 UI가 실행되어야 합니다. 여러 플러그인을 개발하는 경우 `configs.js` 파일 내에서 포트를 수동으로 변경해야 할 수 있습니다.

```tsx
module.exports = {
  name: 'new_plugin',
  port: 3017,
  scope: 'new_plugin',
  exposes: {
    './routes': './src/routes.tsx'
  },
  routes: {
    url: 'http://localhost:3017/remoteEntry.js',
    scope: 'new_plugin',
    module: './routes'
  },
  menus: []
};
```
## 플러그인 위치
`packages/plugin-<new_plugin>-ui/src/configs.js` 파일 내에 설정 섹션이 있습니다. 아래 예시는 새 플러그인을 메인 내비게이션 메뉴에 배치하는 방법을 보여줍니다.

```tsx
menus: [
  {
    text: 'New plugin',
    url: '/new_plugins',
    icon: 'icon-star',
    location: 'mainNavigation',
  }
]
```
설정 메뉴 내에만 배치하려는 경우, 아래 예시를 참조하십시오.

```tsx
menus: [
  {
    text: 'New plugin',
    to: '/new_plugins',
    image: '/images/icons/erxes-18.svg',
    location: 'settings',
    scope: 'new_plugin'
  }
]
```

## 플러그인 활성화
`cli/configs.json` 파일 내의 "plugins" 섹션에는 erxes 시작 시 실행되는 플러그인 이름이 포함되어 있습니다. 다른 플러그인을 활성화하거나, 제거하거나, 재생성하기로 결정한 경우 이 섹션을 구성해야 합니다.

```tsx
{
 "jwt_token_secret": "token",
 "dashboard": {},
 "client_portal_domains": "",
 "elasticsearch": {},
 "redis": {
   "password": ""
 },
 "mongo": {
   "username": "",
   "password": ""
 },
 "rabbitmq": {
   "cookie": "",
   "user": "",
   "pass": "",
   "vhost": ""
 },
 "plugins": [
   {
     "name": "logs"
   },
   {
     "name": "new_plugin",
     "ui": "local"
   }
 ]
}
```
# erxes 실행
`create-plugin` 명령은 `cli/configs.json` 파일에 새 줄을 자동으로 추가하고 필요한 종속성을 설치합니다.

```tsx
{
    "jwt_token_secret": "token",
    "client_portal_domains": "",
    "elasticsearch": {},
    "redis": {
        "password": "pass"
    },
    "mongo": {
        "username": "",
        "password": ""
    },
    "rabbitmq": {
        "cookie": "",
        "user": "",
        "pass": "",
        "vhost": ""
    },
    "plugins": [
      {
        "name": "new_plugin",
        "ui": "local"
      }
    ]
}
```
2. 다음 명령을 실행하세요.
```tsx
cd erxes/cli
yarn install
```

3. 새로 설치한 플러그인과 함께 erxes를 시작하려면 다음 명령을 실행하세요.
```tsx
./bin/erxes.js dev
```