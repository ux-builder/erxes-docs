import { HeroPattern } from '@/components/HeroPattern'

<HeroPattern />

# 배포

다음 문서는 [Docker](https://www.docker.com/) 이미지를 사용하여 [Ubuntu](https://ubuntu.com/)에서 erxes 프로젝트를 설치하는 방법을 안내합니다. 이 가이드는 비즈니스 목적으로 erxes를 사용하려는 모든 사람을 위해 작성되었습니다. erxes에서 추가 플러그인을 개발하거나 커스터마이징하려면 [개발자 설치 가이드](/intro)를 참조하십시오.

Docker는 애플리케이션이 필요한 모든 부분(예: 라이브러리 및 종속성)을 포함하는 컨테이너를 사용하여 애플리케이션을 개발, 배포 및 실행할 수 있는 오픈 소스 플랫폼입니다.

 ---
# 사전 요구 사항
erxes 설치를 시작하기 전에 다음이 필요합니다.

- **4코어 CPU 및 최소 8GB RAM**을 갖춘 서버
- 도메인 컨트롤러의 **A 레코드**가 설치하려는 인스턴스를 가리켜야 함
- **ssh** 프로토콜을 통해 인스턴스에 연결할 수 있는 능력
- **Ubuntu 운영 체제**에서 명령어를 실행할 수 있는 기본 지식


---

# 설치

## **인스턴스에 erxes 사용자 생성**

인스턴스에 연결된 상태에서 다음 단계를 실행합니다. 먼저 `erxes 사용자`를 생성해야 합니다. 이는 erxes 관련 설치 스크립트가 erxes 사용자용으로 작성되었기 때문입니다.
왜 그럴까요?
서버 관리를 위해 **root** 사용자를 사용하지 않기 위해서입니다. 따라서 모든 작업은 `erxes`라는 사용자로 수행됩니다. 이를 위해 다음 명령어를 실행합니다:

```bash
adduser erxes
```
프롬프트가 나타나면, **고유하고 강력한** 비밀번호를 입력합니다.
(질문에 대해 `enter` 또는 `return` 키를 눌러 사용자를 추가합니다)

다음 명령어를 통해 `erxes` 사용자에게 관리자 권한을 부여합니다:

```bash
usermod -aG sudo erxes
```
모든 사전 요구 사항이 완료되었으므로 이제 설치 단계로 진행할 수 있습니다.
## 설치 단계

**1.** nano 또는 vim과 같은 텍스트 편집기를 사용하여 `install.sh` 파일을 만듭니다. 그런 다음 아래 내용을 `install.sh`에 복사합니다. 다음 스크립트는 nginx, certbot, docker, docker-compose 및 nodejs를 서버에 설치합니다.

```bash
#!/bin/bash
            now=$(date +'%H:%M:%S')
            echo -e "\e[1mStep 1 $now : Updating \e[0m"
        sudo apt-get update -y
        # nginx install
            now=$(date +'%H:%M:%S')
            echo -e "\e[1mStep 2 $now : Installing nginx\e[0m"
        sudo apt install nginx -y
        # docker install
        sudo apt update -y
            now=$(date +'%H:%M:%S')
            echo -e "\e[1mStep 3 $now : Installing docker\e[0m"
        sudo apt install apt-transport-https ca-certificates curl software-properties-common -y
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
        sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable"
        apt-cache policy docker-ce
        sudo apt install docker-ce -y
            now=$(date +'%H:%M:%S')
            echo -e "\e[1mStep 4 $now : Installing certbot\e[0m"
        sudo apt install certbot python3-certbot-nginx -y
            now=$(date +'%H:%M:%S')
            echo -e "\e[1mStep 5 $now : Installing docker-compose\e[0m"
        sudo apt-get update -y
        sudo curl -L "https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
            now=$(date +'%H:%M:%S')
            echo -e "\e[1mStep 6 $now : Installing nodejs\e[0m"
            curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash
        #new directory
        sudo apt-get install nodejs -y
            now=$(date +'%H:%M:%S')
            echo -e "\e[1mStep 7 $now : Installing awscli\e[0m"
        sudo apt-get install awscli -y
            now=$(date +'%H:%M:%S')
            echo -e "\e[1mStep 8 $now : Installing npm\e[0m"
        sudo apt install npm -y
            now=$(date +'%H:%M:%S')
            echo -e "\e[1mStep 9 $now : Please enter erxes informations\e[0m"
        sudo npm install -g create-erxes-app -y
            create-erxes-app erxes
```
**2.** `install.sh` 파일을 실행하기 전에 아래 명령어를 사용하여 `install.sh` 파일을 실행 가능하도록 만드세요.
```bash
sudo chmod +x install.sh
```

**3.** `install.sh` 파일을 실행하세요.
```bash
./install.sh
```

**4.** 위의 단계가 완료되면 erxes 사용자로 서버에 다시 로그인하기 위해 로그아웃하고 다시 로그인하세요. 서버에서 로그아웃하려면 다음 명령어를 사용하세요:
```bash
exit
```
<Note>
이전에 root 사용자로 로그인한 경우 몇 번의 명령어 입력이 필요할 수 있습니다.
</Note>

서버에 접속하려면 ssh 프로토콜을 사용할 것입니다. 아래 명령어를 사용하세요:

```bash
ssh erxes@your-ip address-address
```
---

# erxes 프로젝트 시작하기

**1.** 아래 명령어는 erxes 설치 과정을 시작합니다.
```bash
create-erxes-app erxes
```
실행 후 erxes 도메인 이름을 입력하라는 메시지가 표시됩니다.

```bash
https://example.com
```

<Note>
도메인 또는 서브도메인 이름을 http 소켓을 포함하여 아래와 같이 입력하세요:
</Note>
**2.** 위 명령어 실행 후 erxes 디렉토리가 생성됩니다. 그 디렉토리에는 docker-compose.yml, configs.json, package.json, nginx config 파일이 포함되어 있습니다. erxes 디렉토리로 이동하려면 아래 명령어를 사용하세요.

```bash
cd /home/erxes/erxes
```
**3.** /home/erxes/erxes/package.json 파일에서 erxes 패키지 버전을 <a href="https://www.npmjs.com/package/erxes" target="_blank">최신 버전</a>으로 변경하세요.

```bash
{
  "name": "erxes",
  "private": true,
  "version": "0.1.0",
  "scripts": {
    "erxes": "erxes"
  },
  "dependencies": {
    "amqplib": "^0.8.0",
    "create-erxes-app": "0.0.28",
    "dup": "^1.0.0",
    #Change here
    "erxes": "change me",
    "ip": "^1.1.5",
    "up": "^1.0.2"
  }
}
```


**4.** 이제 Docker Swarm 모드를 초기화해야 합니다. 이를 위해 다음 명령어를 사용하세요.

```bash
docker swarm init
docker network create --driver=overlay --attachable erxes
```
<Note>
erxes 디렉토리에는 docker-compose.yml 파일이 있지만, 더 이상 docker-compose up, docker-compose down, docker-compose restart 명령어를 사용하지 않습니다.
</Note>

**5.** 애플리케이션 서비스를 시작하기 전에 데이터베이스를 시작해야 합니다. 다음 명령어는 데이터베이스 서비스를 시작합니다.

```bash
npm run erxes deploy-dbs
```
**6.** 데이터베이스 서비스가 정상적으로 실행되고 있는지 확인하려면 다음 명령어를 사용하세요. 이는 모든 실행 중인 Docker 서비스의 ID, 이름 및 상태 등을 표시합니다. 

```bash
docker ps -a | grep mongo
```
모든 서비스 상태가 up으로 변경될 때까지 기다리세요.
**7.** 이제 MongoDB에 레플리카 셋을 설정해야 합니다. 먼저 MongoDB 컨테이너에 들어가서 MongoDB 인스턴스에 접속한 후 다음 3개의 명령어를 실행합니다.
```bash
docker exec -it <mongo container name> bash
mongo -u erxes -p <auto generated password in configs.json>
rs.initiate();
```
<Note>
몇 번 return 또는 enter 키를 눌러야 할 수 있습니다. 제대로 완료되면 Mongo 셸이 "RS0: primary"로 변경됩니다.
</Note>

Mongo 인스턴스 및 컨테이너를 종료하려면 `두 번 exit 명령어`를 실행하세요.

**8.** 작업 디렉토리 /home/erxes/erxes에 locales 디렉토리를 생성해야 합니다. 이를 위해 다음 명령어를 사용하세요.

```bash
mkdir locales
```

**9.** erxes core uis 및 gateway 서비스를 시작하려면 다음 명령어를 실행합니다. 이 단계 이후 UI는 AWS:s3에서 다운로드되므로 서버가 AWS 인스턴스와 문제없이 통신할 수 있는지 확인하세요.
```bash
npm run erxes up -- --uis
```

After this step ui will be downloaded from AWS:s3 so make sure your server can communicate AWS instances without problem


<Note>
컨테이너는 하나씩 생성되므로 완료될 때까지 기다리세요. 이 동안 상태를 확인하려면 다음 명령어를 사용하세요.
```bash
docker ps -a
```
Docker 서비스를 확인하려면 다음 명령어를 사용하세요.
```bash
docker service ls
```
모든 erxes 서비스가 up 상태여야 합니다. 
`gateway` 컨테이너 상태가 healthy로 변경될 때까지 기다리세요. 또한 gateway 컨테이너는 마지막에 시작되어야 합니다.
</Note></Note>

**10.** 이제 웹 서버를 설정해야 합니다. 먼저 erxes를 위해 nginx.service를 구성해야 합니다. 이를 위해 `/home/erxes/erxes`에 생성된 `nginx.conf` 파일을 `/etc/nginx/sites-enabled/`로 이동해야 합니다. 다음 명령어를 사용하세요.

```bash
sudo mv nginx.conf /etc/nginx/sites-enabled/erxes.conf
```
**11.** 그 후 nginx 구성을 테스트해야 합니다. 이를 위해 다음 명령어를 사용하세요.
```bash
sudo nginx -t
```
문제가 발생하면 `/etc/nginx/sites-enabled/nginx.conf` 파일을 다음 내용으로 교체할 수 있습니다.

```bash
server {
        server_name example.com;
        index index.html;
        client_max_body_size 50M;
        client_header_buffer_size 32k;

        location / {
                access_log /var/log/nginx/erxes-front.access.log;
                error_log /var/log/nginx/erxes-front.error.log;
                proxy_pass http://127.0.0.1:3000;
                proxy_http_version 1.1;
                proxy_redirect off;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-Host $host;
                proxy_set_header X-Forwarded-Server $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /widgets/ {
                access_log /var/log/nginx/erxes-widgets.access.log;
                error_log /var/log/nginx/erxes-widgets.error.log;
                proxy_pass http://127.0.0.1:3200/;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host $host;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_http_version 1.1;
        }

        location /gateway/ {
                access_log /var/log/nginx/erxes-api.access.log;
                error_log /var/log/nginx/erxes-api.error.log;
                proxy_pass http://127.0.0.1:3300/;
                proxy_http_version 1.1;
                proxy_buffering off;
                proxy_redirect off;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-Server $host;
                proxy_set_header X-Forwarded-Host $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "Upgrade";
        }

        location /mobile-app/ {
                access_log /var/log/nginx/erxes-mobile-app.access.log;
                error_log /var/log/nginx/erxes-mobile-app.error.log;
                proxy_pass http://127.0.0.1:4100/;
                proxy_http_version 1.1;
                proxy_buffering off;
                proxy_redirect off;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-Server $host;
                proxy_set_header X-Forwarded-Host $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "Upgrade";
        }

        location /integrations/ {
                access_log /var/log/nginx/erxes-integrations.access.log;
                error_log /var/log/nginx/erxes-integrations.error.log;
                proxy_pass http://127.0.0.1:3400/;
                proxy_http_version 1.1;
                proxy_redirect off;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-Host $host;
                proxy_set_header X-Forwarded-Server $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
        }
        location /dashboard/front {
                access_log /var/log/nginx/erxes-integrations.access.log;
                error_log /var/log/nginx/erxes-integrations.error.log;
                proxy_pass http://127.0.0.1:4200;
                proxy_http_version 1.1;
                proxy_redirect off;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-Host $host;
                proxy_set_header X-Forwarded-Server $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /dashboard/api/ {
                access_log /var/log/nginx/erxes-integrations.access.log;
                error_log /var/log/nginx/erxes-integrations.error.log;
                proxy_pass http://127.0.0.1:4300/;
                proxy_http_version 1.1;
                proxy_redirect off;
                proxy_set_header Host $http_host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-Host $host;
                proxy_set_header X-Forwarded-Server $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
    ```
**12.** nginx 테스트가 성공 메시지를 표시하면 nginx를 재시작해야 합니다. 이를 위해 다음 명령어를 사용하세요.
    ```bash
    sudo service nginx restart
    ```
**13.** Erxes는 보안 연결에서만 작동하므로 무료 SSL 인증서를 생성하기 위해 `Certbot`을 사용합니다. 이를 구성하려면 다음 명령어를 사용하세요.

```bash
sudo certbot --nginx
```
<Note>
도메인의 A 레코드를 erxes 호스트 머신으로 지정해야 인증서를 받을 수 있습니다. 그렇지 않으면 certbot이 인증서 주문을 생성하지 않습니다.
</Note>

이 명령어를 입력한 후, 이메일 및 구독 정보를 제공하고 약관에 동의하세요. 그 후 '리디렉션' 옵션에 대해 묻는 메시지가 표시됩니다. 보안상 이 옵션을 활성화하는 것을 강력히 권장합니다. 이 단계가 완료되면 브라우저를 열고 우리의 제품을 즐기세요.

# 새로운 플러그인 추가하기
erxes에 새로운 플러그인을 추가하는 것은 간단한 작업입니다. `/home/erxes/erxes/configs.json` 파일의 `"plugins:"[{}]`에 플러그인 이름을 추가한 후 `npm run erxes up -- --uis` 명령어를 실행하기만 하면 됩니다. 그러나 대시보드와 같은 일부 플러그인은 추가 서비스가 필요할 수 있으며, 이에 대해서는 다른 섹션에서 다루겠습니다. 아래에는 모든 플러그인을 위한 필요한 구성 라인이 포함된 `이상적인` configs.json 파일 내용이 있습니다. 다음 내용을 주의 깊게 읽고 일부 라인을 교체해야 합니다.

```bash
{
    "jwt_token_secret": "will be generated in configs.json",
    "db_server_address": "ip address of your machine",
    "image_tag": "dev",
    "domain": "https://example.com",
    "widgets": {
        "domain": "https://example.com/widgets"
    },
    "elasticsearch": {},
    "essyncer": {},
    "redis": {
        "password": "will be generated in configs.json"
    },

    "mongo": {
        "username": "erxes",
        "password": "will be generated in configs.json",
    },
    "rabbitmq": {
        "cookie": "",
        "user": "erxes",
        "pass": "will be generated in configs.json",
        "vhost": ""
    },

    "plugins": [
        {
            "name": "inbox",
            "extra_env": {
                "INTEGRATIONS_MONGO_URL": "will be generated in docker-compose-dbs.yml",
                "FB_MONGO_URL": "will be generated in docker-compose-dbs.yml"
            }
        },
        {
            "name": "cards"
        },
        {
            "name": "contacts"
        },
        {
            "name": "internalnotes"
        },
        {
            "name": "notifications"
        },
        {
            "name": "automations",
            "db_name": "erxes_automations"
        },
        {
            "name": "products"
        },
        {
            "name": "forms"
        },
        {
            "name": "inventories"
        },
        {
            "name": "segments"
        },
        {
            "name": "tags"
        },
        {
            "name": "engages"
        },
        {
            "name": "logs",
            "db_name": "erxes_logger"
        },
        {
            "name": "clientportal",
            "extra_env": {
                "JWT_TOKEN_SECRET": ""
                    }
        },
        {
            "name": "webbuilder"
        },
        {
            "name": "knowledgebase"
        },
        {
            "name": "emailtemplates"
        },
        {
            "name": "integrations",
            "db_name": "erxes_integrations",
            "extra_env": {
                "ENDPOINT_URL": "https://enterprise.erxes.io"
            }
        },
        {
            "name": "dashboard"
        },
        {
            "name": "documents"
        },
        {
            "name": "filemanager"
        },
        {
            "name": "facebook",
            "extra_env": {
                "ENDPOINT_URL": "https://enterprise.erxes.io",
                "MONGO_URL": "will be generated in docker-compose-dbs.yml"
            }
        }
    ]
}
```
---

# 대시보드 플러그인 추가하기
앞서 언급한 대로 대시보드 플러그인을 설치하려면 몇 가지 추가 단계가 필요합니다. 먼저 `mongobi` 인증서를 생성해야 합니다. 이를 위해 다음 명령어를 사용하세요.

```bash
openssl rand -base64 756 > mongo-key
    sudo chmod 400 mongo-key && sudo chown 999:999 mongo-key
    openssl req -newkey rsa:2048 -nodes -keyout key.pem -x509 -days 365 -out certificate.pem --batch
    cat key.pem certificate.pem > mongo.pem
    ```

이 명령어는 mongobi 인증서를 생성합니다. 그 후 `/home/erxes/erxes/configs.json` 파일에 `mongobi`를 다음과 같이 추가해야 합니다.

```bash
 "mongo": {
        "username": "erxes",
        "password": "will be generated in configs.json",
    },
    "mongobi:{},
```
마지막으로 `npm run erxes up -- --uis` 명령어를 실행하세요.

<Note>
configs.json 파일을 변경할 때마다 변경 사항을 적용하려면 `npm run erxes up -- --uis` 명령어를 실행해야 합니다.
</Note>

---
# Elasticsearch 실행하기
서버가 요구되는 크기보다 큰 경우 Elasticsearch와 함께 erxes를 사용할 수 있습니다. 이를 위해 다음 단계를 따라야 합니다.

**1.** /home/erxes/erxes 디렉토리로 이동합니다.
```bash
cd /home/erxes/erxes
```
**2.** configs.json 파일에 다음 라인을 추가합니다. 위치는 중요하지 않습니다.
```bash
"essyncer": {},
"elasticsearch" : {},
```
**3.** 다시 데이터베이스를 배포하려면 다음 명령어를 실행합니다.
```bash
npm run erxes deploy-dbs
npm run erxes up -- --uis
```
---

# erxes 제거하기
**1.** 먼저 서버를 깔끔하게 유지하기 위해 몇 가지 명령어를 사용하여 Docker 스택과 스웜의 중지된 컨테이너를 제거합니다.
 ```bash
 docker stack ls
 ```
다음 명령어는 스택 정보를 표시합니다. 스택을 제거하려면 다음 명령어를 사용하세요.
 ```bash
docker stack rm erxes
 ```

**2.** 모든 중지된 컨테이너를 제거하려면 다음 명령어를 사용하세요.

중지된 이미지를 나열하고 제거합니다.

```bash
docker images -f dangling=true
docker rmi $(docker images -q -f dangling=true)
```
중지된 컨테이너를 나열하고 제거합니다.
```bash
docker ps -a -f status=exited
docker rm $(docker ps -a -q -f status=exited)
```
중지된 볼륨을 나열하고 제거합니다.

<Note>
볼륨에는 데이터가 포함될 수 있으므로 신중하게 수행하세요.
</Note>

```bash
docker volume ls -f dangling=true
docker volume rm $(docker volume ls -q -f dangling=true)
```
---
# 설치 비디오

 [](https://youtu.be/Vq2TbSqnWOY?si=zruf8u9b0mCuC-c7)

---

## erxes 커뮤니티에 참여하기
설치 과정에서 문제가 발생하면 [GitHub](https://github.com/erxes/erxes)에 이슈를 생성하거나 [Discord](https://discord.com/invite/rPf9FYaA3F) 커뮤니티에서 도움을 받으세요.
